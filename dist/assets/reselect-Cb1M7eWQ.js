var v=Symbol("NOT_FOUND");function z(e,n=`expected a function, instead received ${typeof e}`){if(typeof e!="function")throw new TypeError(n)}function T(e,n=`expected an object, instead received ${typeof e}`){if(typeof e!="object")throw new TypeError(n)}function j(e,n="expected all items to be functions, instead received the following types: "){if(!e.every(t=>typeof t=="function")){const t=e.map(o=>typeof o=="function"?`function ${o.name||"unnamed"}()`:typeof o).join(", ");throw new TypeError(`${n}[${t}]`)}}var b=e=>Array.isArray(e)?e:[e];function M(e){const n=Array.isArray(e[0])?e[0]:e;return j(n,"createSelector expects all input-selectors to be functions, but received the following types: "),n}function I(e,n){const t=[],{length:o}=e;for(let s=0;s<o;s++)t.push(e[s].apply(null,n));return t}function x(e){let n;return{get(t){return n&&e(n.key,t)?n.value:v},put(t,o){n={key:t,value:o}},getEntries(){return n?[n]:[]},clear(){n=void 0}}}function O(e,n){let t=[];function o(r){const l=t.findIndex(u=>n(r,u.key));if(l>-1){const u=t[l];return l>0&&(t.splice(l,1),t.unshift(u)),u.value}return v}function s(r,l){o(r)===v&&(t.unshift({key:r,value:l}),t.length>e&&t.pop())}function c(){return t}function a(){t=[]}return{get:o,put:s,getEntries:c,clear:a}}var $=(e,n)=>e===n;function A(e){return function(t,o){if(t===null||o===null||t.length!==o.length)return!1;const{length:s}=t;for(let c=0;c<s;c++)if(!e(t[c],o[c]))return!1;return!0}}function _(e,n){const t=typeof n=="object"?n:{equalityCheck:n},{equalityCheck:o=$,maxSize:s=1,resultEqualityCheck:c}=t,a=A(o);let r=0;const l=s<=1?x(a):O(s,a);function u(){let i=l.get(arguments);if(i===v){if(i=e.apply(null,arguments),r++,c){const f=l.getEntries().find(y=>c(y.value,i));f&&(i=f.value,r!==0&&r--)}l.put(arguments,i)}return i}return u.clearCache=()=>{l.clear(),u.resetResultsCount()},u.resultsCount=()=>r,u.resetResultsCount=()=>{r=0},u}var D=class{constructor(e){this.value=e}deref(){return this.value}},F=typeof WeakRef<"u"?WeakRef:D,W=0,w=1;function g(){return{s:W,v:void 0,o:null,p:null}}function E(e,n={}){let t=g();const{resultEqualityCheck:o}=n;let s,c=0;function a(){var h;let r=t;const{length:l}=arguments;for(let f=0,y=l;f<y;f++){const d=arguments[f];if(typeof d=="function"||typeof d=="object"&&d!==null){let p=r.o;p===null&&(r.o=p=new WeakMap);const m=p.get(d);m===void 0?(r=g(),p.set(d,r)):r=m}else{let p=r.p;p===null&&(r.p=p=new Map);const m=p.get(d);m===void 0?(r=g(),p.set(d,r)):r=m}}const u=r;let i;if(r.s===w)i=r.v;else if(i=e.apply(null,arguments),c++,o){const f=((h=s==null?void 0:s.deref)==null?void 0:h.call(s))??s;f!=null&&o(f,i)&&(i=f,c!==0&&c--),s=typeof i=="object"&&i!==null||typeof i=="function"?new F(i):i}return u.s=w,u.v=i,i}return a.clearCache=()=>{t=g(),a.resetResultsCount()},a.resultsCount=()=>c,a.resetResultsCount=()=>{c=0},a}function q(e,...n){const t=typeof e=="function"?{memoize:e,memoizeOptions:n}:e,o=(...s)=>{let c=0,a=0,r,l={},u=s.pop();typeof u=="object"&&(l=u,u=s.pop()),z(u,`createSelector expects an output function after the inputs, but received: [${typeof u}]`);const i={...t,...l},{memoize:h,memoizeOptions:f=[],argsMemoize:y=E,argsMemoizeOptions:d=[]}=i,p=b(f),m=b(d),C=M(s),R=h(function(){return c++,u.apply(null,arguments)},...p),S=y(function(){a++;const k=I(C,arguments);return r=R.apply(null,k),r},...m);return Object.assign(S,{resultFunc:u,memoizedResultFunc:R,dependencies:C,dependencyRecomputations:()=>a,resetDependencyRecomputations:()=>{a=0},lastResult:()=>r,recomputations:()=>c,resetRecomputations:()=>{c=0},memoize:h,argsMemoize:y})};return Object.assign(o,{withTypes:()=>o}),o}var U=q(E),K=Object.assign((e,n=U)=>{T(e,`createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`);const t=Object.keys(e),o=t.map(c=>e[c]);return n(o,(...c)=>c.reduce((a,r,l)=>(a[t[l]]=r,a),{}))},{withTypes:()=>K});export{U as a,q as c,_ as l};
